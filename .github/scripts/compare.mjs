#!/usr/bin/env node
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */

/**
 * Next.jsã®ãƒãƒ³ãƒ‰ãƒ«è§£æçµæœã‚’æ¯”è¼ƒã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * Pages Routerã¨App Routerï¼ˆNext.js 13ä»¥é™ï¼‰ã®ä¸¡æ–¹ã«å¯¾å¿œ
 *
 * å‡¦ç†æ¦‚è¦:
 * 1. ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã¨æ¯”è¼ƒå¯¾è±¡ãƒ–ãƒ©ãƒ³ãƒã®ãƒãƒ³ãƒ‰ãƒ«è§£æçµæœã‚’èª­ã¿è¾¼ã‚€
 * 2. ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã®å¤‰åŒ–ã‚’åˆ†æ
 * 3. è¿½åŠ ã•ã‚ŒãŸãƒšãƒ¼ã‚¸ã¨å¤‰æ›´ã•ã‚ŒãŸãƒšãƒ¼ã‚¸ã‚’æ¤œå‡º
 * 4. åˆ†æçµæœã‚’Markdownå½¢å¼ã§ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›
 * 5. App Routerã¨Pages Routerã®ãƒšãƒ¼ã‚¸ã‚’åŒºåˆ¥ã—ã¦è¡¨ç¤º
 */

import { filesize as originalFilesize } from 'filesize'
import fs from 'fs'
import path from 'path'
import { getBuildOutputDirectory, getOptions } from './utils.mjs'
import { DETAILS_GLOBAL_BUNDLE, renderDetailsPageChanges } from './templates.mjs'

// Override default filesize options to display a non-breakable space as a spacer.
const filesize = (bytes, options) => {
  return originalFilesize(bytes, {
    spacer: 'Â ',
    ...options,
  })
}

// Pull options from `package.json`
const options = getOptions()

const BUDGET = options.budget
const BUDGET_PERCENT_INCREASE_RED = options.budgetPercentIncreaseRed
// Threshold for trivial changes that can be ignored (< 0.01% change)
const TRIVIAL_CHANGE_THRESHOLD = 0.01
// this must be explicitly set to false not to render
const SHOW_DETAILS =
  options.showDetails === undefined ? true : options.showDetails
const BUILD_OUTPUT_DIRECTORY = getBuildOutputDirectory(options)
const PACKAGE_NAME = options.name
const SKIP_COMMENT_IF_EMPTY = options.skipCommentIfEmpty

// import the current and base branch bundle stats
const currentBundle = JSON.parse(
  fs.readFileSync(
    path.join(
      process.cwd(),
      BUILD_OUTPUT_DIRECTORY,
      'analyze/__bundle_analysis.json'
    ),
    'utf8'
  )
)
let baseBundle = {}
let hasBaseBundle = false
try {
  baseBundle = JSON.parse(
    fs.readFileSync(
      path.join(
        process.cwd(),
        BUILD_OUTPUT_DIRECTORY,
        'analyze/base/bundle/__bundle_analysis.json'
      ),
      'utf8'
    )
  )
  hasBaseBundle = true
} catch (err) {
  console.log('No base bundle analysis found or invalid format. Running in single-bundle mode.')
}

// kick it off
let output = `## ğŸ“¦ Next.js Bundle Analysis for ${PACKAGE_NAME}

This analysis was generated by the [Next.js Bundle Analysis action](https://github.com/hashicorp/nextjs-bundle-analysis). ğŸ¤–

`

// pull the global bundle out, we handle this separately
const globalBundleCurrent = currentBundle.__global || { gzip: 0, raw: 0 }
// æ¯”è¼ƒå¯¾è±¡ã®ãƒ™ãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€ã‚¼ãƒ­å€¤ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
const globalBundleBase = (hasBaseBundle && baseBundle.__global)
  ? baseBundle.__global
  : { gzip: 0, raw: 0 }

if ('__global' in currentBundle) delete currentBundle.__global
if ('__global' in baseBundle) delete baseBundle.__global

// calculate the difference between the current bundle and the base branch's
let globalBundleChanges = false
const globalGzipDiff = globalBundleCurrent.gzip - globalBundleBase.gzip
// only report a global bundle size change if we don't have a minimum change
// threshold configured, or if the change is greater than the threshold
// ã¾ãŸã€æ¯”è¼ƒå¯¾è±¡ã®ãƒ™ãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã«ã®ã¿å¤‰æ›´ã‚’å ±å‘Šã™ã‚‹
if (
  hasBaseBundle &&
  globalGzipDiff !== 0 &&
  (!('minimumChangeThreshold' in options) ||
    Math.abs(globalGzipDiff) > options.minimumChangeThreshold)
) {
  globalBundleChanges = {
    page: 'global',
    raw: globalBundleCurrent.raw,
    gzip: globalBundleCurrent.gzip,
    gzipDiff: globalGzipDiff,
    isIncrease: Math.sign(globalGzipDiff) > 0,
  }
}

// now we're going to go through each of the pages in the current bundle and
// run analysis on each one.
const changedPages = []
const newPages = []

for (let page in currentBundle) {
  const currentStats = currentBundle[page]
  const baseStats = hasBaseBundle ? (baseBundle[page] || null) : null

  // if the page does't appear in the base bundle, it is a new page, we can
  // push this directly to its own category. we also don't compare it to anything
  // because its a new page.
  if (!baseStats) {
    // Format the page path for display
    const displayPage = formatPagePath(page)
    newPages.push({ page: displayPage, originalPath: page, ...currentStats })
  } else if (currentStats.gzip !== baseStats.gzip) {
    // otherwise, we run a comparsion between the current page and base branch page
    // we push these to their own category for rendering later
    const rawDiff = currentStats.raw - baseStats.raw
    const gzipDiff = currentStats.gzip - baseStats.gzip
    const isIncrease = Math.sign(gzipDiff) > 0
    // only report a page size change if we don't have a minimum change
    // threshold configured, or if the change is greater than the threshold
    if (
      !('minimumChangeThreshold' in options) ||
      Math.abs(gzipDiff) > options.minimumChangeThreshold
    ) {
      // Format the page path for display
      const displayPage = formatPagePath(page)
      changedPages.push({ page: displayPage, originalPath: page, ...currentStats, rawDiff, gzipDiff, isIncrease })
    }
  }
}

// with our data in hand, we now get to a bunch of output formatting.
// we start with any changes to the global bundle.
if (globalBundleChanges) {
  // start with the headline, which will render differently depending on whether
  // there was an increase of decrease.
  output += `### ${
    globalBundleChanges.isIncrease ? 'âš ï¸' : 'ğŸ‰'
  }  Global Bundle Size ${
    globalBundleChanges.isIncrease ? 'Increased' : 'Decreased'
  }

`
  // this is where we actually generate the table including the changes.
  output += markdownTable(globalBundleChanges)

  // and we end with some extra details further explaining the data above
  if (SHOW_DETAILS) {
    output += `\n${DETAILS_GLOBAL_BUNDLE}\n`
  }
}

// next up is the newly added pages
if (newPages.length) {
  // this might seem like too much, but I feel like this type of small detail really
  // matters <3
  const plural = newPages.length > 1 ? 's' : ''
  output += `### New Page${plural} Added

The following page${plural} ${
    plural === 's' ? 'were' : 'was'
  } added to the bundle from the code in this PR:

`
  // as before, run the data in as a table
  output += markdownTable(newPages, globalBundleCurrent) + '\n'

  // there is no "details" section here, didnt't seem necessary. i'm open to one being
  // added though!
}

// finally, we run through the pages that existed in the base branch, still exist in the
// current branch, and have changed size.
if (changedPages.length) {
  // same flow here as the others:
  // - headline that adjusts wording based on number of changes
  // - table containing all the resources and info
  // - details section
  const plural = changedPages.length > 1 ? 's' : ''
  output += `### ${changedPages.length} Page${plural} Changed Size

The following page${plural} changed size from the code in this PR compared to its base branch:

`
  output += markdownTable(changedPages, globalBundleCurrent, globalBundleBase)

  // this details section is a bit more responsive, it will render slightly different
  // details depending on whether a budget is being used, since the information presented
  // is quite different.
  if (SHOW_DETAILS) {
    output += `\n${renderDetailsPageChanges({
      budgetPercentIncreaseRed: BUDGET_PERCENT_INCREASE_RED,
      budget: BUDGET && globalBundleCurrent ? BUDGET : null
    })}\n`
  }
}

// and finally, if there are no changes at all, we try to be clear about that
const hasNoChanges =
  (!hasBaseBundle || (!newPages.length && !changedPages.length && !globalBundleChanges))
if (hasNoChanges) {
  if (!hasBaseBundle) {
    output += 'No base bundle found for comparison. Changes will be detected in the next commit.'
  } else {
    output += 'This PR introduced no changes to the JavaScript bundle! ğŸ™Œ'
  }
}

// we add this tag so that our action can be able to easily and consistently find the
// right comment to edit as more commits are pushed.
output += `<!-- __NEXTJS_BUNDLE_${PACKAGE_NAME} -->`

// however, if ignoreIfEmpty is true, set output to an empty string
if (hasNoChanges && SKIP_COMMENT_IF_EMPTY) {
  output = ''
}

// log the output, mostly for testing and debugging. this will show up in the
// github actions console.
console.log(output)

// and to cap it off, we write the output to a file which is later read in as comment
// contents by the actions workflow.
fs.writeFileSync(
  path.join(
    process.cwd(),
    BUILD_OUTPUT_DIRECTORY,
    'analyze/__bundle_analysis_comment.txt'
  ),
  output.trim()
)

// Util Functions

/**
 * Generates markdown table header for bundle analysis
 * @param {Object|null} globalBundleCurrent - Current global bundle data
 * @param {boolean} showBudget - Whether to show budget column
 * @returns {string} Markdown table header
 */
function generateTableHeader(globalBundleCurrent, showBudget) {
  const columns = ['Page', 'Size (compressed)']

  if (globalBundleCurrent) {
    columns.push('First Load')
  }

  if (showBudget) {
    columns.push(`% of Budget (\`${filesize(BUDGET)}\`)`)
  }

  const header = columns.join(' | ')
  const separator = columns.map(() => '---').join('|')

  return `${header} |\n|${separator}|`
}

/**
 * Calculates budget-related metrics for a page
 * @param {Object} pageData - Page bundle data
 * @param {Object|null} globalBundleCurrent - Current global bundle
 * @param {Object|null} globalBundleBase - Base global bundle
 * @param {boolean} showBudget - Whether budget calculation is needed
 * @returns {Object} Budget metrics
 */
function calculateBudgetMetrics(pageData, globalBundleCurrent, globalBundleBase, showBudget) {
  const firstLoadSize = globalBundleCurrent
    ? pageData.gzip + globalBundleCurrent.gzip
    : 0

  const budgetPercentage = showBudget
    ? ((firstLoadSize / BUDGET) * 100).toFixed(2)
    : 0

  // Calculate previous budget percentage if we have base bundle and diff
  // Base page size = current page size - diff
  const previousBudgetPercentage = hasBaseBundle && globalBundleBase && pageData.gzipDiff
    ? (((globalBundleBase.gzip + (pageData.gzip - pageData.gzipDiff)) / BUDGET) * 100).toFixed(2)
    : 0

  const budgetChange = previousBudgetPercentage && hasBaseBundle
    ? (previousBudgetPercentage - budgetPercentage).toFixed(2)
    : 0

  return {
    firstLoadSize,
    budgetPercentage,
    previousBudgetPercentage,
    budgetChange
  }
}

/**
 * Generates a single table row for bundle data
 * @param {Object} pageData - Page bundle data
 * @param {Object|null} globalBundleCurrent - Current global bundle
 * @param {Object|null} globalBundleBase - Base global bundle
 * @param {boolean} showBudget - Whether to show budget column
 * @param {boolean} showBudgetDiff - Whether to show budget diff
 * @returns {string} Markdown table row
 */
function generateTableRow(pageData, globalBundleCurrent, globalBundleBase, showBudget, showBudgetDiff) {
  const metrics = calculateBudgetMetrics(pageData, globalBundleCurrent, globalBundleBase, showBudget)

  return (
    `| \`${pageData.page}\`` +
    renderSize(pageData, showBudgetDiff) +
    renderFirstLoad(globalBundleCurrent, metrics.firstLoadSize) +
    renderBudgetPercentage(
      showBudget,
      metrics.budgetPercentage,
      metrics.previousBudgetPercentage,
      metrics.budgetChange
    ) +
    ' |\n'
  )
}

/**
 * Generates a complete markdown table for bundle analysis data
 * @param {Array|Object} _data - Bundle data (can be array or single object)
 * @param {Object|null} globalBundleCurrent - Current global bundle
 * @param {Object|null} globalBundleBase - Base global bundle for comparison
 * @returns {string} Complete markdown table
 */
function markdownTable(_data, globalBundleCurrent, globalBundleBase) {
  // Early return for empty data
  if (!_data || _data.length === 0) {
    return ''
  }

  const data = [].concat(_data)
  const showBudget = globalBundleCurrent && BUDGET
  const showBudgetDiff = BUDGET && !!globalBundleBase && hasBaseBundle

  const header = generateTableHeader(globalBundleCurrent, showBudget)
  const rows = data
    .map(pageData => generateTableRow(pageData, globalBundleCurrent, globalBundleBase, showBudget, showBudgetDiff))
    .join('')

  return `${header}\n${rows}`
}

// as long as global bundle is passed, render the first load size, which is the global
// bundle plus the size of the current page, representing the total JS required
// in order to land on that page.
function renderFirstLoad(globalBundleCurrent, firstLoadSize) {
  if (!globalBundleCurrent) return ''
  return ` | ${filesize(firstLoadSize)}`
}

// renders the bundle size of the current page. if there is a diff from the base branch
// size of the page, also displays the size difference, unless there is a budget set and
// the budget has a diff from the base branch, in which case the diff is not rendered.
function renderSize(d, showBudgetDiff) {
  const gzd = d.gzipDiff
  // å·®åˆ†ãŒç„¡ã„å ´åˆã‚„ã€ãƒ™ãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«ãŒãªã„å ´åˆã¯0ã«ã™ã‚‹
  // ãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚ºã«å¯¾ã™ã‚‹å¤‰åŒ–ç‡ã‚’è¨ˆç®—: (å·®åˆ† / ãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚º) * 100
  // ãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚º = ç¾åœ¨ã®ã‚µã‚¤ã‚º - å·®åˆ†
  const baseSize = d.gzip - gzd
  const percentChange = (gzd && baseSize !== 0) ? ((gzd / baseSize) * 100) : 0
  return ` | \`${filesize(d.gzip)}\`${
    gzd && !showBudgetDiff && hasBaseBundle
      ? ` _(${renderStatusIndicator(percentChange)}${filesize(gzd)})_`
      : ''
  }`
}

// renders the percentage of the budget taken up by the current page's first load js
// for changed pages, also renders the percent change compared to the base branch size
function renderBudgetPercentage(
  showBudget,
  budgetPercentage,
  previousBudgetPercentage,
  budgetChange
) {
  if (!showBudget) return ''

  // we round to 2 decimal places for number values, if there was a change smaller than that
  // its displayed as "+/- <0.01%", signaling that it's not a consequential change, but it
  // still is a change technically, so we still show it.
  const budgetChangeText = ` _(${renderStatusIndicator(budgetChange)}${
    Math.abs(budgetChange) < TRIVIAL_CHANGE_THRESHOLD
      ? '+/- <0.01%'
      : budgetChange + '%'
  })_`

  // only render the budget change for changed pages (indicated by previousBudgetPercentage
  // being passed in) and when baseBundle exists
  return ` | ${budgetPercentage}%${
    previousBudgetPercentage && hasBaseBundle ? budgetChangeText : ''
  }`
}

// given a percentage that a metric has changed, renders a colored status indicator
// this makes it easier to call attention to things that need attention
//
// in general:
// - yellow means "keep an eye on this"
// - red means "this is a problem"
// - green means "this is a win"
function renderStatusIndicator(percentageChange) {
  let res = ''
  if (percentageChange > 0 && percentageChange < BUDGET_PERCENT_INCREASE_RED) {
    res += 'ğŸŸ¡ +'
  } else if (percentageChange >= BUDGET_PERCENT_INCREASE_RED) {
    res += 'ğŸ”´ +'
  } else if (Math.abs(percentageChange) < TRIVIAL_CHANGE_THRESHOLD) {
    res += ''
  } else {
    res += 'ğŸŸ¢ '
  }
  return res
}

/**
 * ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚ŒãŸãƒšãƒ¼ã‚¸ãƒ‘ã‚¹ã‚’è¿”ã™é–¢æ•°
 * App Routerã¨Pages Routerã®ãƒšãƒ¼ã‚¸è¡¨ç¤ºã‚’é©åˆ‡ã«æ•´å½¢ã™ã‚‹
 * @param {string} pagePath - å…ƒã®ãƒšãƒ¼ã‚¸ãƒ‘ã‚¹
 * @returns {string} è¡¨ç¤ºç”¨ã«æ•´å½¢ã•ã‚ŒãŸãƒ‘ã‚¹
 */
function formatPagePath(pagePath) {
  // App Routerç”¨ã®ãƒ‘ã‚¹ã®å ´åˆ (/_app/ ã§å§‹ã¾ã‚‹å ´åˆ)
  if (pagePath.startsWith('/_app/')) {
    // /_app/ ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤ã—ã€App Routerã§ã‚ã‚‹ã“ã¨ã‚’æ˜ç¤º
    return `[App] ${pagePath.substring(6)}`;
  }

  // /_shared/ ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™ï¼ˆå…±æœ‰ãƒãƒ£ãƒ³ã‚¯ï¼‰
  if (pagePath.startsWith('/_shared/')) {
    return pagePath;
  }

  // Pages Routerç”¨ã®ãƒ‘ã‚¹ã®å ´åˆã¯ã€ãã®ã¾ã¾è¿”ã™
  return pagePath;
}
